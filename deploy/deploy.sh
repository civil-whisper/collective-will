#!/usr/bin/env bash
set -euo pipefail

ENV="${1:?Usage: deploy.sh <production|staging> <image-tag>}"
IMAGE_TAG="${2:?Usage: deploy.sh <production|staging> <image-tag>}"

BASE_DIR="/opt/collective-will"
ENV_DIR="${BASE_DIR}/${ENV}"
DEPLOY_SRC="${BASE_DIR}/repo-deploy"
PUBLIC_ENV="${DEPLOY_SRC}/public.env.${ENV}"
SECRETS_ENV="${ENV_DIR}/.env.secrets"
LEGACY_ENV="${ENV_DIR}/.env"
RUNTIME_ENV="${ENV_DIR}/.env"
TMP_FILTERED_SECRETS="$(mktemp)"
TMP_RUNTIME_ENV="$(mktemp)"

if [[ "$ENV" != "production" && "$ENV" != "staging" ]]; then
  echo "Error: environment must be 'production' or 'staging'" >&2
  exit 1
fi

cleanup() {
  rm -f "$TMP_FILTERED_SECRETS" "$TMP_RUNTIME_ENV"
}
trap cleanup EXIT

echo "==> Deploying ${ENV} with image tag: ${IMAGE_TAG}"

mkdir -p "${ENV_DIR}"

cp "${DEPLOY_SRC}/docker-compose.prod.yml" "${ENV_DIR}/docker-compose.yml"

if [[ ! -f "${PUBLIC_ENV}" ]]; then
  echo "Error: ${PUBLIC_ENV} not found. Ensure deploy/public.env.${ENV} is copied to the VPS." >&2
  exit 1
fi

SECRET_SOURCE=""
if [[ -f "${SECRETS_ENV}" ]]; then
  SECRET_SOURCE="${SECRETS_ENV}"
elif [[ -f "${LEGACY_ENV}" ]]; then
  SECRET_SOURCE="${LEGACY_ENV}"
  echo "==> Legacy mode: using ${LEGACY_ENV} as secret source"
  echo "==> Recommended: move secrets to ${SECRETS_ENV}"
else
  echo "Error: no secrets source found. Provide ${SECRETS_ENV} (preferred) or ${LEGACY_ENV}." >&2
  exit 1
fi

echo "==> Building merged runtime env at ${RUNTIME_ENV}"
awk -F= '
  FNR == NR {
    if ($0 ~ /^[[:space:]]*#/ || $0 ~ /^[[:space:]]*$/) next
    key = $1
    gsub(/^[[:space:]]+|[[:space:]]+$/, "", key)
    public_keys[key] = 1
    next
  }
  {
    if ($0 ~ /^[[:space:]]*#/ || $0 ~ /^[[:space:]]*$/) {
      print
      next
    }
    key = $1
    gsub(/^[[:space:]]+|[[:space:]]+$/, "", key)
    if (key in public_keys) {
      printf("Skipping duplicate key from secrets source: %s\n", key) > "/dev/stderr"
      next
    }
    print
  }
' "$PUBLIC_ENV" "$SECRET_SOURCE" > "$TMP_FILTERED_SECRETS"

{
  echo "# Autogenerated by deploy.sh (${ENV})"
  echo "# Public source: ${PUBLIC_ENV}"
  echo "# Secret source: ${SECRET_SOURCE}"
  echo
  cat "$PUBLIC_ENV"
  echo
  cat "$TMP_FILTERED_SECRETS"
} > "$TMP_RUNTIME_ENV"

install -m 600 "$TMP_RUNTIME_ENV" "$RUNTIME_ENV"

cd "${ENV_DIR}"

export IMAGE_TAG

# ---------------------------------------------------------------------------
# Guard: tear down any stale stack whose project name differs from ours.
#
# The canonical project name is the directory basename (staging / production).
# A previous version of this script used COMPOSE_PROJECT_NAME="collective-will-<env>",
# which created a parallel stack that grabbed the same ports.  This block
# detects leftover containers from that (or any other) mismatched project
# name and removes them so the new deploy can bind its ports.
# ---------------------------------------------------------------------------
EXPECTED_PREFIX="${ENV}-"
STALE=$(docker ps -a --format '{{.Names}}' \
  | grep -i "${ENV}" \
  | grep -v "^${EXPECTED_PREFIX}" \
  || true)

if [[ -n "$STALE" ]]; then
  echo "==> Removing stale containers from a previous project name:"
  echo "$STALE"
  echo "$STALE" | xargs -r docker rm -f
fi

echo "==> Pulling latest images..."
docker compose pull

echo "==> Starting services..."
docker compose up -d --remove-orphans

echo "==> Cleaning up old images..."
docker image prune -f

echo "==> Verifying deployment..."
docker compose ps

RUNNING=$(docker compose ps --format '{{.Service}} {{.State}}' | grep -c "running" || true)
EXPECTED=$(docker compose config --services | wc -l | tr -d ' ')
MIGRATE_COUNT=$(docker compose config --services | grep -c "migrate" || true)
EXPECTED_RUNNING=$((EXPECTED - MIGRATE_COUNT))

if [[ "$RUNNING" -lt "$EXPECTED_RUNNING" ]]; then
  echo "WARNING: Only ${RUNNING}/${EXPECTED_RUNNING} services running. Check logs:" >&2
  docker compose ps
  docker compose logs --tail=20
  exit 1
fi

echo "==> Deploy complete for ${ENV} (${RUNNING}/${EXPECTED_RUNNING} services running)"
